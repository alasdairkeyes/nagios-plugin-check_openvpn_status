#!/usr/bin/perl

    ## check_openvpn_status
    ## https://github.com/alasdairkeyes/nagios-plugin-check_openvpn_status
    ## See README.md and LICENSE files

my $VERSION = '0.2.0';


    ## Use required modules
use strict;
use warnings;
use Monitoring::Plugin qw(%ERRORS);
use DateTime;
use Getopt::Long qw(:config no_ignore_case);


    ## Defaults
my $default_status_file = '/etc/openvpn/openvpn-status.log';
my $default_max_warning     = 500;
my $default_max_critical    = 1000;


    ## Config variables
my $status_file     = $default_status_file;
my $max_warning     = $default_max_warning;
my $max_critical    = $default_max_critical;
my $min_warning;
my $min_critical;
my @required_common_names;

my $help;


    ## Get command line switches
GetOptions (
    "f=s"   => \$status_file,
    "W=i"   => \$max_warning,
    "C=i"   => \$max_critical,
    "w=i"   => \$min_warning,
    "c=i"   => \$min_critical,
    "N=s"   => \@required_common_names,
    "h"     => \$help,
);


    ## Show help?
help()
    if ($help);


    ## Make sure input is valid
validate_user_inputs($min_warning, $min_critical, $max_warning, $max_critical);



    ## Get status information
my $file_contents = get_file_contents($status_file);
my $vpn_status = parse_output($file_contents);


    ## Validate openvpn status
check_status_age($vpn_status);
check_number_of_clients($vpn_status, $max_warning, $max_critical, $min_warning, $min_critical);
ensure_required_common_names_connected($vpn_status, @required_common_names);

    ## All OK
quit('OK', "$vpn_status->{ number_of_clients } clients are logged in");


sub validate_user_inputs {
    my $min_warning = shift;
    my $min_critical = shift;
    my $max_warning = shift;
    my $max_critical = shift;


        ## Check max values
    quit('CRITICAL', 'Maximum warning value (-W) must be lower than maximum critical (-C)')
        if ($max_warning >= $max_critical);

    quit('CRITICAL', 'Both minimum critical value (-c) and minimum warning value (-w) must both be set or neither set')
        if (($min_critical && !$min_warning) || (!$min_critical && $min_warning));

    if ($min_warning) {
        quit('CRITICAL', 'Minimum critical value (-c) must be lower than minimum warning value (-w)')
            if ($min_warning <= $min_critical);

        quit('CRITICAL', 'Minimum critical/warning values must be less than maximum critical/warning values')
            if ($min_warning >= $max_warning);
    }

    return 1;   
}


sub get_file_contents {
    my $status_file = shift;

        ## File checks
    quit ("CRITICAL", "File $status_file doesn't exist")
        unless (-f $status_file);

        ## Load file
    open (my $fh, '<', $status_file)
        || quit ("CRITICAL", "Cannot read status file: $!");

        ## Clean file
    my $contents = [<$fh>];
    $_ =~ s/\n$//
        foreach (@$contents);

    close ($fh);
    return $contents
}


sub parse_output {
    my $contents = shift;

    my $month_to_number = {
        Jan => '01',
        Feb => '02',
        Mar => '03',
        Apr => '04',
        May => '05',
        Jun => '06',
        Jul => '07',
        Aug => '08',
        Sep => '09',
        Oct => '10',
        Nov => '11',
        Dec => '12'
    };

        ## Check first line is valid
    quit('CRITICAL', "File doesn't appear to be a valid status file")
        unless ($$contents[0] eq "OpenVPN CLIENT LIST");
    shift (@$contents);

        ## Check the last line is valid
    quit('CRITICAL', "Status file appears to be incomplete, last line isn't END")
        unless ($$contents[-1] eq "END");
    pop (@$contents);

        ## Parse the date in the file
    my $date_line = shift(@$contents);
    my $updated;
    if ($date_line =~ /^Updated,(\w{3})\s(\w{3})\s+(\d{1,2})\s(\d{2}):(\d{2}):(\d{2})\s(\d{4})$/) {
        $updated = DateTime->new(
            time_zone   => 'local',
            year        => $7,
            month       => $month_to_number->{ $2 },
            day         => $3,
            hour        => $4,
            minute      => $5,
            second      => $6,
        );
    }
    
    quit('CRITICAL', 'Failed to parse timestamp from status file')
        unless ($updated);

        ## Get client information header
    my $client_header = shift(@$contents);
    my @client_keys = split(',', $client_header);
    foreach (@client_keys) {
        $_ =~ s/[^a-zA-Z]/_/;
        $_ = lc($_);
    }

        ## Hashref to store all status info
    my $vpn_status = {
        updated => $updated,
        clients => [],
    };

        ## Parse out client information into hash
    while ($$contents[0] ne "ROUTING TABLE") {
        my $line = shift(@$contents);

        my @client_values = split(',', $line);
        my %client_hash;
        @client_hash{@client_keys} = @client_values;
        push (@{$vpn_status->{ clients }}, \%client_hash)
    }

        ## Calculate number of clients
    $vpn_status->{ number_of_clients } = scalar(@{$vpn_status->{ clients}});

        ## Don't parse anymore for now. This is all we need.
    return $vpn_status;

}


    ## Check age of OpenVPN output
sub check_status_age {
    my $vpn_status = shift;

    my $now = DateTime->now(
        time_zone   => 'local'
    );
    my $updated = $vpn_status->{ updated };
    my $age = $now->epoch - $updated->epoch;

        ## Check the last time the file was updated
    if ($age > 180) {
        quit('CRITICAL', 'Status file not updated in the last 180 seconds')
    } elsif ($age > 120) {
        quit('WARNING', 'Status file not updated in the last 120 seconds')
    }
    return 1;
}


sub check_number_of_clients {
    my $vpn_status = shift;
    my $max_warning = shift;
    my $max_critical = shift;
    my $min_warning = shift;
    my $min_critical = shift;
    my $number_of_clients = $vpn_status->{ number_of_clients };

        ## Check max values
    if ($number_of_clients >= $max_critical) {
        quit('CRITICAL', "$number_of_clients clients are logged in");
    } elsif ($number_of_clients >= $max_warning) {
        quit('WARNING', "$number_of_clients clients are logged in");
    }

        ## Check min values
    if ($min_warning) {
        if ($number_of_clients <= $min_critical) {
            quit('CRITICAL', "$number_of_clients clients are logged in");
        } elsif ($number_of_clients <= $min_warning) {
            quit('WARNING', "$number_of_clients clients are logged in");
        }
    }
    return 1;
}


sub ensure_required_common_names_connected {
    my $vpn_status = shift;
    my @required_common_names = @_;

    if (scalar(@required_common_names)) {
        my @missing_common_names;
        foreach my $client (@required_common_names) {
            push (@missing_common_names, $client)
                unless (grep { $_->{ common_name } eq $client } @{$vpn_status->{ clients }});
        }

        if (scalar(@missing_common_names)) {
            quit('CRITICAL', "Common names '" .
                                join("','", @missing_common_names) . "' are not connected");
        }
    }
    return 1;
}


    ## Function to handle output
sub quit {
    my $status = shift;
    my $message = join('',@_);
    ## Pipe in nagios seems to strip of stuff afterwards, remove it
    $message =~ s/\|//g;
    print $status . ": $message\n";
    exit $ERRORS{ $status };
}


    ## Help message
sub help {
    print "Version $VERSION\n";
    print "USAGE\n\n";
    print "     check_openvpn_status [ --f=/path/to/openvpn/status.log ] [ -w 5 ] [ -c 10 ] [ -C commonname1 ] [ -h ]\n";
    print "OPTIONS\n";
    print "     -h     This help message\n";
    print "     -f     The path of the OpenVPN status file (Default: $default_status_file)\n";
    print "     -W     Warning maximum value for number of clients connected (Default: $default_max_warning)\n";
    print "     -C     Critical maximum value for number of clients connected (Default: $default_max_critical)\n";
    print "     -w     Warning minimum value for number of clients connected (Not set by default)\n";
    print "     -c     Critical minimum value for number of clients connected (Not set by default)\n";
    print "     -N     Require common names, can be used multiple times (-N commonname1 -N commonname2)\n";
    print "\n";
    print "NOTES\n";
    print "     To enable to status file, use the 'status' option in your config file (See https://openvpn.net/index.php/open-source/documentation/howto.html)\n";
    print "     The status file is owned by root, so add this nagios script to sudo to allow your nagios/nrpe user to read it\n";
    print "\n";
    exit 0;
}
